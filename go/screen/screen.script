local INPUT = require "libs.input"
local WORLD = require "libs.world"
local SCREEN = require "libs.screen"
local CONST = require "libs.constants"
local RAYS = require "libs.rays"
local LUME = require "libs.lume"
local WALLS = require "assets.walls.walls"
local MAP = WORLD.map

local MATH_CEIL = math.ceil

function init(self)
	self.resource_path = go.get("#model", "texture0")
	self.native_table = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, leds = SCREEN.NODES}
	go.set_position(vmath.vector3(SCREEN.WIDTH/2, SCREEN.HEIGHT/2, 0))
	local scale = vmath.vector3(50 * SCREEN.WIDTH, 50 * SCREEN.HEIGHT, 1)
	go.set_scale(scale)
end

local function get_color(cell)
	return WALLS[cell][1]
end	

local function ver_line(camera, ray_id, draw_start, draw_end, wall, texture_x, side)
	local start_pixel = MATH_CEIL((wall.width-1) * texture_x) + 1
	local y_width = (draw_end - draw_start)
	for y = draw_start, draw_end do
		local y_pixel = MATH_CEIL((y - draw_start) / y_width * 63) +1
		local x_pixel = start_pixel
		local color = wall[(y_pixel-1) * wall.width + x_pixel]
		SCREEN.set_node((camera.bounds.x - 1) + ray_id, y, color)
	end
end	

local function floor_casting(self, camera, start_y, start_x, perp_dist, side, map_x, map_y, floors, catet_x, catet_y, ray)
	local end_x = camera.position.x + catet_x
	local end_y = camera.position.y + catet_y
	local floor_height = start_y -  camera.bounds.y  + 1
	local half_height = camera:get_height()/2
	for y = start_y -  camera.bounds.y + 1, 1, -1 do
		local current_dist =  half_height / (half_height - y)
		local weight = current_dist / perp_dist
		local floor_x = (weight * end_x + (1.0 - weight) * camera.position.x)
		local floor_y = (weight * end_y + (1.0 - weight) * camera.position.y)
		local cell_x = MATH_CEIL(floor_x)
		local cell_y = MATH_CEIL(floor_y)
		local floor =  WALLS[floors[cell_y][cell_x]]
		local texture_x = LUME.round((floor_x % 1)  * (floor.width - 1)) + 1
		local texture_y = LUME.round((floor_y % 1)  * (floor.height - 1)) + 1
		--local color = floor[1]
		local color = floor[(texture_y - 1) * floor.width + texture_x]
		SCREEN.set_node(start_x, y, color)
	end
end	

local function on_ray_intersept(self, camera, wall_cells, perp_dist, catet_x, catet_y,  map_x, map_y, side, ray, texture_x)
	local center_camera = math.ceil(camera.bounds.y - 1 + camera:get_height()/2)
	local line_height = camera:get_height() / (perp_dist)
	local half_line_height = LUME.round(line_height / 2)
	local draw_start = - half_line_height + center_camera
	local draw_end =  half_line_height + center_camera
	if draw_start < camera.bounds.y then draw_start = camera.bounds.y end
	if draw_end > camera.bounds.w then draw_end = camera.bounds.w end
	local x = (camera.bounds.x - 1) + ray
	native_raycasting.vert_line(x, draw_start, draw_end, WALLS[wall_cells[map_y][map_x]], texture_x, SCREEN.NODES, SCREEN.WIDTH)
	--floor_casting(self, camera, draw_start - 1, ray, perp_dist, side, map_x, map_y, MAP.FLOORS,catet_x, catet_y)
end	


function update(self, dt)
	--print("***************")
	local time = os.clock()
	WORLD.update_camera()
	SCREEN.clear()
	RAYS.cast_rays(WORLD.player.camera, WORLD.map.MAP, on_ray_intersept, self)
	SCREEN.draw()
	local header = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, type = resource.TEXTURE_TYPE_2D, format = resource.TEXTURE_FORMAT_RGB, num_mip_maps = 0}
	resource.set_texture(self.resource_path, header, SCREEN.BUFFER)
	print("time:" .. os.clock() - time)
	
end


