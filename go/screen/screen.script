local INPUT = require "libs.input"
local WORLD = require "libs.world"
local SCREEN = require "libs.screen"
local CONST = require "libs.constants"
local RAYS = require "libs.rays"
local LUME = require "libs.lume"
local WALLS = require "assets.walls.walls"
local MAP = WORLD.map

local MATH_CEIL = math.ceil

function init(self)
	self.resource_path = go.get("#model", "texture0")
	self.native_table = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, leds = SCREEN.NODES}
	go.set_position(vmath.vector3(SCREEN.WIDTH/2, SCREEN.HEIGHT/2, 0))
	local scale = vmath.vector3(50 * SCREEN.WIDTH, 50 * SCREEN.HEIGHT, 1)
	go.set_scale(scale)
	local camera = WORLD.player.camera
	native_raycasting.set_map(WORLD.map);
end

local function test()
	local camera = WORLD.player.camera
	local time = os.clock()
	for i=1, 100 do
		native_raycasting.update_camera(camera.position.x, camera.position.y, camera.angle)
		native_raycasting.cast_rays()
	end
	print("time:" .. os.clock() - time)
end	

function update(self, dt)
	local camera = WORLD.player.camera
	WORLD.update_camera()
	--test()
	--WORLD.player.position.x = LUME.clamp(WORLD.player.position.x, 1.5, 23)
	--WORLD.player.position.y = LUME.clamp(WORLD.player.position.y, 1.5, 23)
	--	WORLD.update_camera()
	local time = os.clock()
	native_raycasting.update_camera(camera.position.x, camera.position.y, camera.angle)
	native_raycasting.cast_rays()
	local header = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, type = resource.TEXTURE_TYPE_2D, format = resource.TEXTURE_FORMAT_RGB, num_mip_maps = 0}
	resource.set_texture(self.resource_path, header, SCREEN.BUFFER)
	print("time:" .. os.clock() - time)
end


