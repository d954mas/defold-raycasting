local INPUT = require "libs.input"
local WORLD = require "libs.world"
local SCREEN = require "libs.screen"
local CONST = require "libs.constants"
local RAYS = require "libs.rays"
local LUME = require "libs.lume"
local WALLS = require "assets.walls.walls"
local MAP = WORLD.map

function init(self)
	self.resource_path = go.get("#model", "texture0")
	self.native_table = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, leds = SCREEN.NODES}
	go.set_position(vmath.vector3(SCREEN.WIDTH/2, SCREEN.HEIGHT/2, 0))
	local scale = vmath.vector3(50 * SCREEN.WIDTH, 50 * SCREEN.HEIGHT, 1)
	go.set_scale(scale)
end

local function get_color(cell)
	return WALLS[cell][1]
end	

local function ver_line(camera, ray_id, draw_start, draw_end, wall, texture_x, side)
	local start_pixel = math.ceil(wall.width * texture_x)
	local y_width = (draw_end - draw_start)
	for x = 1, camera.strip_size do
		for y = draw_start, draw_end do
			local y_pixel = math.ceil((y - draw_start) / y_width * 63) +1
			local x_pixel = LUME.clamp(start_pixel + x, 0, 64)
			local color = wall[(y_pixel-1) * wall.width + x_pixel]
			SCREEN.set_node((camera.bounds.x - 1) + x + (ray_id - 1) * camera.strip_size, y, color)
		end
	end	
end	

local function floor_casting(self, camera, start_y, start_x, perp_dist, side, map_x, map_y, floors, catet_x, catet_y)
	--if start_x~=1 then return end
	local floor_start_x, floor_start_y
	if side == 0 then
		floor_start_x = map_x
		floor_start_y = map_y + 1
	elseif side == 1 then
		floor_start_x = map_x + 1
		floor_start_y = map_y -- -
	elseif side == 2 then
		floor_start_x = map_x
		floor_start_y = map_y -- +
	else
		floor_start_x = map_x
		floor_start_y = map_y -- +
	end	

	--local distance_x = math.abs(camera.position.x - floor_start_x)
	--local distance_y = math.abs(camera.position.y - floor_start_y)
	local distance_x = catet_x
	local distance_y = catet_y
	local distance = vmath.vector3(distance_x, distance_y, 0)
	local perp_scale = perp_dist/vmath.length(distance)
	print(perp_scale)
	distance = distance * perp_scale

	local floor_height = start_y -  camera.bounds.y  + 1
	for y = start_y -  camera.bounds.y + 1, 1, -1 do
		local distance_scale = y/floor_height
		local floor_x = camera.position.x + distance_x * distance_scale - 1
		local floor_y = camera.position.y + distance_y * distance_scale - 1
		local cell_x = math.ceil(floor_x)
		local cell_y = math.ceil(floor_y)
		local floor =  WALLS[floors[cell_y][cell_x]]
		local texture_x = LUME.round((floor_x % 1)  * (floor.width - 1)) + 1
		local texture_y = LUME.round((floor_y % 1)  * (floor.height - 1)) + 1
		local color = floor[(texture_y - 1) * floor.width + texture_x]
		SCREEN.set_node(start_x, y, color)
	end
end	

local function on_ray_intersept(self, camera, wall_cells, perp_dist, catet_x, catet_y,  map_x, map_y, side, ray, texture_x)
	local center_camera = math.ceil(camera.bounds.y - 1 + camera:get_height()/2)
	local line_height = camera:get_height() / (perp_dist)
	local half_line_height = LUME.round(line_height / 2)
	local draw_start = - half_line_height + center_camera
	local draw_end =  half_line_height + center_camera
	if draw_start < camera.bounds.y then draw_start = camera.bounds.y end
	if draw_end > camera.bounds.w then draw_end = camera.bounds.w end
	ver_line(WORLD.player.camera, ray, draw_start, draw_end,  WALLS[wall_cells[map_y][map_x]], texture_x, side)
	floor_casting(self, camera, draw_start - 1, ray, perp_dist, side, map_x, map_y, MAP.FLOORS,catet_x, catet_y)
end	


function update(self, dt)
	--print("***************")
	WORLD.update_camera()
	local time = os.clock()
	SCREEN.clear()
	RAYS.cast_rays(WORLD.player.camera, WORLD.map.MAP, on_ray_intersept, self)
	SCREEN.draw()
	--print("time:" .. os.clock() - time)
	local header = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, type = resource.TEXTURE_TYPE_2D, format = resource.TEXTURE_FORMAT_RGB, num_mip_maps = 0}
	resource.set_texture(self.resource_path, header, SCREEN.BUFFER)
end


