local INPUT = require "libs.input"
local WORLD = require "libs.world"
local SCREEN = require "libs.screen"
local CONST = require "libs.constants"
local RAYS = require "libs.rays"
local LUME = require "libs.lume"
local WALLS = require "assets.walls.walls"
local MAP = WORLD.map

local MATH_CEIL = math.ceil

function init(self)
	self.resource_path = go.get("#model", "texture0")
	self.native_table = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, leds = SCREEN.NODES}
	go.set_position(vmath.vector3(SCREEN.WIDTH/2, SCREEN.HEIGHT/2, 0))
	local scale = vmath.vector3(50 * SCREEN.WIDTH, 50 * SCREEN.HEIGHT, 1)
	go.set_scale(scale)
	local camera = WORLD.player.camera
	native_raycasting.init_camera(camera.position.x, camera.position.y, camera.size.x, camera.size.y)
	native_raycasting.set_map(WORLD.map)
	native_raycasting.init_wall_textures(WALLS)
end

local function get_color(cell)
	return WALLS[cell][1]
end	

local function floor_casting(self, camera, start_y, start_x, perp_dist, side, map_x, map_y, floors, catet_x, catet_y, ray)
	local end_x = camera.position.x + catet_x
	local end_y = camera.position.y + catet_y
	local floor_height = start_y -  camera.bounds.y  + 1
	local half_height = camera.size.y/2
	for y = start_y -  camera.bounds.y + 1, 1, -1 do
		local current_dist =  half_height / (half_height - y)
		local weight = current_dist / perp_dist
		local floor_x = (weight * end_x + (1.0 - weight) * camera.position.x)
		local floor_y = (weight * end_y + (1.0 - weight) * camera.position.y)
		local cell_x = MATH_CEIL(floor_x)
		local cell_y = MATH_CEIL(floor_y)
		local floor =  WALLS[floors[cell_y][cell_x]]
		local texture_x = LUME.round((floor_x % 1)  * (floor.width - 1)) + 1
		local texture_y = LUME.round((floor_y % 1)  * (floor.height - 1)) + 1
		--local color = floor[1]
		local color = floor[(texture_y - 1) * floor.width + texture_x]
		native_raycasting.set_pixel(start_x, y, color)
	end
end	

local function on_ray_intersept(self, camera, wall_cells, perp_dist, catet_x, catet_y,  map_x, map_y, side, ray, texture_x)
	local line_height = camera.size.y / (perp_dist)
	local half_line_height = LUME.round(line_height / 2)
	local draw_start = - half_line_height + camera.center.y
	local draw_end =  half_line_height + camera.center.y
	if draw_start < camera.bounds.y then draw_start = camera.bounds.y end
	if draw_end > camera.bounds.w - 1 then draw_end = camera.bounds.w - 1 end
	local x = camera.bounds.x + ray - 1
	-- wall_cells[map_x, map_y]
	native_raycasting.vert_line(x, draw_start, draw_end,wall_cells[map_y][map_x], texture_x)

	local end_position_x = camera.position.x + catet_x
	local end_position_y = camera.position.y + catet_y
	if draw_start ~= camera.bounds.y then
		--native_raycasting.floor_casting(x, draw_start - 1, camera.bounds.y, camera.position.x, camera.position.y, camera.size.y,
			--end_position_x, end_position_y, perp_dist)
	end
	if draw_end ~= camera.bounds.w - 1 then
		--native_raycasting.floor_casting(x, draw_end + 1, camera.bounds.w-1, camera.position.x, camera.position.y, camera.size.y,
			-- end_position_x, end_position_y, perp_dist)
	end
	
end	


function update(self, dt)
	--print("***************")
	local time = os.clock()
	WORLD.player.position.x = LUME.clamp(WORLD.player.position.x, 1.5, 23)
	WORLD.player.position.y = LUME.clamp(WORLD.player.position.y, 1.5, 23)
	WORLD.update_camera()
	SCREEN.clear()
	RAYS.cast_rays(WORLD.player.camera, WORLD.map.MAP)
	RAYS.cast_rays(WORLD.player.camera, WORLD.map.MAP, on_ray_intersept, self)
	local header = {width = SCREEN.WIDTH, height = SCREEN.HEIGHT, type = resource.TEXTURE_TYPE_2D, format = resource.TEXTURE_FORMAT_RGB, num_mip_maps = 0}
	resource.set_texture(self.resource_path, header, SCREEN.BUFFER)
	print("time:" .. os.clock() - time)
	
end


